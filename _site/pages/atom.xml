<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>雪剑20的博客</title>
    <link>http://cloudyer.github.io</link>
    <description>雪剑20的博客</description>
    
      <item>
        <title>2014 个人总结</title>
        <link>http://cloudyer.github.io/2015/01/01/my-2014.html</link>
        <guid isPermaLink="true">http://cloudyer.github.io/2015/01/01/my-2014.html</guid>
        <pubDate>Thu, 01 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在2014年里，我在求学、职业生涯以及家庭关系上都有过多次尝试和选择。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;留学申请&lt;/h2&gt;

&lt;p&gt;英语考试和学校申请总的时间大概是从去年8月中旬到今年1月中旬，历时5个月，这段时间是我有记忆以来最困难的一段时期。其中包括说服家人支持我留学，考过TOEFL和GRE，以及学校的选择和申请。&lt;/p&gt;

&lt;p&gt;最后由于考试结果不理想，只申请了一个学校尝试，之后打算继续考试和准备来年的申请。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;远程工作&lt;/h2&gt;

&lt;p&gt;从13年底加入澳洲这家公司，到今年5月离开，是我第一次尝试远程工作。由于那边公司节奏也不快，所以除了工作外，我可以有闲暇的时间完成留学的各种琐事，以及处理研究生学校退学的一些事情。&lt;/p&gt;

&lt;p&gt;工作中收获很多，一方面要熟悉远程工作方式，另一方面为了实现项目的需求需要不断学习提升自己。最后积累了比较多的网络安全知识和实际开发经验。&lt;/p&gt;

&lt;p&gt;但是后来由于公司重组，原定的很多计划都不能再继续，因此我有了很长一段空闲期。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;几次旅行&lt;/h2&gt;

&lt;p&gt;这段空闲期里，正好给了我很多机会出去旅行。我在14年上半年去游了华山和普陀山。一直想抽空把图片整理一下，写一下游记… 但是一直没有完成，看来只能拖到15年了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;新公司&lt;/h2&gt;

&lt;p&gt;旅行归来以后开始考虑自己接下来的计划，选择一个既有利于自己发展，又对个人限制比较少的公司工作，这样可以让我继续自己留学的目标。&lt;/p&gt;

&lt;p&gt;在几次面试和选择以后，最后加入了一个创业公司，开始全职工作。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;留学&lt;/h2&gt;

&lt;p&gt;5月中旬，我不幸被一波拒信AOE砸中。14Fall的入学没戏了，不过学校接着给我发来一封调剂录取，说我如果愿意接受学校国际学校的语言课程，可以14Fall加入国际学院，然后15Spring或者15Fall再进入正式的Master学院。&lt;/p&gt;

&lt;p&gt;和家人和老板都商量过以后，确定接受调剂，先到美帝熟悉环境。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;语言学习&lt;/h2&gt;

&lt;p&gt;语言学习过程其实也是熟悉未来生活和学习环境的过程。事实证明早来也有早来的好处，经过几个月的学习，我的英文水平可以应付了日常生活和学术的基本要求。&lt;/p&gt;

&lt;p&gt;其间除了探索洛杉矶，还去过一次旧金山旅行，感受了一下湾区风光。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;总得说来，这一年经历了很多，也成长了很多。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>2013阅读书单</title>
        <link>http://cloudyer.github.io/2013/12/20/book-list-of-2013.html</link>
        <guid isPermaLink="true">http://cloudyer.github.io/2013/12/20/book-list-of-2013.html</guid>
        <pubDate>Fri, 20 Dec 2013 00:00:00 +0800</pubDate>
        <description>
</description>
      </item>
    
      <item>
        <title>PHP可变变量</title>
        <link>http://cloudyer.github.io/2012/09/27/php-variable-variables.html</link>
        <guid isPermaLink="true">http://cloudyer.github.io/2012/09/27/php-variable-variables.html</guid>
        <pubDate>Thu, 27 Sep 2012 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;什么叫可变变量&lt;/h3&gt;

&lt;p&gt;不知道大家在使用php的时候是否遇到这样一种情况，即想将一个变量的内容作为另一个变量的名称。在php中，这个需求可以通过可变变量（Variable variables）来实现。&lt;/p&gt;

&lt;p&gt;可变变量的一般形式为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$var=“foo”;
$$var=1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里， 其实等同于向将var展开，然后再以它的值作为真正的变量名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$foo=1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;可变变量妙用&lt;/h3&gt;
&lt;p&gt;#### 类的动态实例化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$var=“foo”;
$a=new $foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;循环定义变量&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;for($i=0;$i&amp;lt;10;$i++){
${aa.$i}=“a”;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;动态调用方法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;class test_class{
  var $func=‘display_UK’;
  function display_UK(){
    echo “Hello”;
  }
  function display_FR(){
    echo “Bonjour”;
  }
  function display(){
    $this-&amp;gt;{$this-&amp;gt;func}();
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>JS中防止浏览器屏蔽window.open</title>
        <link>http://cloudyer.github.io/2012/09/27/open-widown-in-javascript.html</link>
        <guid isPermaLink="true">http://cloudyer.github.io/2012/09/27/open-widown-in-javascript.html</guid>
        <pubDate>Thu, 27 Sep 2012 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;有的时候我们需要一些弹出窗来作为临时信息显示，在js代码中直接使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.open(url,“_blank”,option);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可实现跳转，而且还可以传递一些参数。&lt;/p&gt;

&lt;p&gt;但是有个问题是，很多浏览器不支持代码触发上述代码，这个问题在平常使用中显得很不方便，尤其是我们经常用ajax返回值来触发一个新页面。&lt;/p&gt;

&lt;p&gt;为了防止被屏蔽，可以有两种方式解决。&lt;br /&gt;
1、在用户点击事件中增加监听程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button onclick=“test()”&amp;gt;点击&amp;lt;/button&amp;gt;
&amp;lt;script type=“text/javascript”&amp;gt;
var is_finished=false;
function test(){
$.get(“/”,function(){
is_finished=true;
});
test2();
}
function test2(){
if(is_finished){
window.open(“http://www.baidu.com”,“_blank”);
}else{
setTimeout(test2,1000);
}
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、在点击后先打开空白页，之后再修改地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button onclick=“test()”&amp;gt;点击&amp;lt;/button&amp;gt;
&amp;lt;script type=“text/javascript”&amp;gt;
function test(){
var frame=window.open(“about:blank”,“_blank”);
$.get(“/”,function(){
frame.location=“http://www.baidu.com”;
});
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>PHP操作Session的原理及提升安全性时的一个问题</title>
        <link>http://cloudyer.github.io/2012/09/19/php-session-security.html</link>
        <guid isPermaLink="true">http://cloudyer.github.io/2012/09/19/php-session-security.html</guid>
        <pubDate>Wed, 19 Sep 2012 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;sessioncookie&quot;&gt;Session和Cookie基本介绍&lt;/h3&gt;

&lt;p&gt;相同点：两者都是保存用户的临时信息，以方便用户和网站之间的交互&lt;/p&gt;

&lt;p&gt;不同点：Session保存在服务器端，只有服务器端才可查看和修改。服务器端通过客户端在cookie中携带的session_id来获得保存在服务器端的用户数据。Cookie保存在客户端，服务端和客户端都可以对其进行修改。&lt;/p&gt;

&lt;h3 id=&quot;session&quot;&gt;Session的工作原理&lt;/h3&gt;

&lt;p&gt;首先测试如下一段代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
session_start();//开启session
echo ‘Session id:’.session_id().‘&amp;lt;br&amp;gt;’;//显示此次交互的session_id
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面显示结果为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Session id:ihrk96384qjvvsqmce0dlkla04
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使不停刷新页面，依然不变，说明服务器端是可以识别出客户端，那么它是如何做到的呢？&lt;/p&gt;

&lt;p&gt;我们可以查看一下他们的第一次HTTP交互(先清空一次cookie和缓存再测试)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Request Header:
GET /phptest/test2.php HTTP/1.1
Host: localhost
Cookie:
Response Header:
Set-Cookie: PHPSESSID=sastrf9cikeij6meoe3055brq3; path=/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了说明问题，我只取要用到的信息，从请求头可以看到，这个时候客户端没有给服务端传Cookie内容。而返回的头信息中，服务端指明了set-cookie要设置一个PHPSESSID的内容，保存在”/”目录下。&lt;/p&gt;

&lt;p&gt;来看第二次交互：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Request Header:
GET /phptest/test2.php HTTP/1.1
Host: localhost
Cookie:PHPSESSID=sastrf9cikeij6meoe3055brq3
Response Header:
Set-Cookie:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一次结果显示服务器端没有再要求写Cookie，而客户端主动上传了上次获得的PHPSESSID值，也就是这种机制，使服务端”认识”了客户端。只要服务端没有要求再次写session，则以后的交互将一直以此session_id作为客户端的身份标志。&lt;/p&gt;

&lt;h3 id=&quot;sessionid&quot;&gt;服务器端修改Session_id&lt;/h3&gt;

&lt;p&gt;当然session_id不是永久不变的，当我们清空过一次Cookie以后就发现以前登录了的网站都得重新登陆。再次登陆的时候，我们又会以新的session_id来进行重新确认身份。（注：还有别的方式可以传递session_id值，例如query string等）。&lt;/p&gt;

&lt;p&gt;其实从上一个例子中我们就可以看到，服务器端修改session_id其实是通过重写一次cookie来实现的，这次重写发生在一次请求完成以后，即传回的HTTP头中说明的。&lt;/p&gt;

&lt;p&gt;为了防止Session劫持，我们可能需要通过每次请求都更改session_id来确保用户是本人登录的。在php中，可以使用以下方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
session_start();//开启session
        echo ‘Old Session id:’.session_id().‘&amp;lt;br&amp;gt;’;
session_regenerate_id(true);//重置session_id，并使原session无效
        echo ‘New Session id:’.session_id().‘&amp;lt;br&amp;gt;’;
    ?&amp;gt; 页面显示结果为：

Old Session id:mqk5sfudpu9ikgp49vc825ggo6
New Session id:mrck9n85v190reupsni4ob6lo5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见session_id在使用了session_regenerate_id()以后发生了变化，变化写入方式同第二点介绍的，服务器端在返回的HTTP头中加入Set-Cookie。&lt;/p&gt;

&lt;h3 id=&quot;sessionregenerateid&quot;&gt;session_regenerate_id()的一个问题&lt;/h3&gt;

&lt;p&gt;在实际操作中，session_id的保存位置可以通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;session_set_cookie_params()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来修改，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
session_set_cookie_params(0,‘/’,‘testdomain’);
session_start();//开启session
        echo ‘Old Session id:’.session_id().‘&amp;lt;br&amp;gt;’;
session_regenerate_id(true);//重置session_id，并使原session无效
        echo ‘New Session id:’.session_id().‘&amp;lt;br&amp;gt;’;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这种方式下，session_id的默认domain被修改，但是session_regenerate_id()是不识别的。这不知道算不算php的一个bug，为了解决这个问题，我们必须使用手动方式重置session保存，修改代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
session_set_cookie_params(0,‘/’,‘testdomain’);
session_start();//开启session
        echo ‘Old Session id:’.session_id().‘&amp;lt;br&amp;gt;’;
session_regenerate_id(true);//重置session_id，并使原session无效
        echo ‘New Session id:’.session_id().‘&amp;lt;br&amp;gt;’;
setcookie(session_name(),session_id(),0,‘/’,‘testdomain’);//手动更新session_id
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来就可以每次交互更新session_id了……虽然有些复杂，但是经测试可行。&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>